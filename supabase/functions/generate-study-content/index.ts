import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'supabase'
import { corsHeaders } from '../_shared/cors.ts'

interface ContentGenerationRequest {
  userId: string;
  contentType: 'learning_path' | 'lesson' | 'flashcards' | 'quiz' | 'explanation';
  prompt: string;
  parameters: {
    category?: string;
    difficulty?: 'beginner' | 'intermediate' | 'advanced' | 'expert';
    languagePair?: string;
    sourceLanguage?: string;
    targetLanguage?: string;
    lessonCount?: number;
    flashcardCount?: number;
    questionCount?: number;
    topic?: string;
    specialization?: string;
  };
}

interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
  usageMetadata?: {
    promptTokenCount: number;
    candidatesTokenCount: number;
    totalTokenCount: number;
  };
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    const request: ContentGenerationRequest = await req.json()

    if (!request.userId || !request.contentType || !request.prompt) {
      return new Response(
        JSON.stringify({ error: 'Missing required parameters' }),
        {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      )
    }

    // Get Google Cloud API key from environment
    const googleApiKey = Deno.env.get('GOOGLE_CLOUD_API_KEY')
    if (!googleApiKey) {
      return new Response(
        JSON.stringify({ error: 'Google Cloud API key not configured' }),
        {
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      )
    }

    // Log the request to database
    const { data: requestRecord } = await supabaseClient
      .from('ai_content_requests')
      .insert({
        user_id: request.userId,
        request_type: request.contentType,
        prompt: request.prompt,
        parameters: request.parameters,
        status: 'processing',
        model_used: 'gemini-pro'
      })
      .select()
      .single()

    const startTime = Date.now()

    try {
      // Prepare the prompt based on content type
      const systemPrompt = getSystemPrompt(request.contentType, request.parameters)
      const fullPrompt = `${systemPrompt}\n\nUser Request: ${request.prompt}\n\nParameters: ${JSON.stringify(request.parameters)}`

      // Call Google Gemini API
      const geminiResponse = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${googleApiKey}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: fullPrompt
              }]
            }],
            generationConfig: {
              temperature: 0.7,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 8192,
            },
            safetySettings: [
              {
                category: "HARM_CATEGORY_HARASSMENT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_HATE_SPEECH",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              },
              {
                category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                threshold: "BLOCK_MEDIUM_AND_ABOVE"
              }
            ]
          })
        }
      )

      if (!geminiResponse.ok) {
        const errorText = await geminiResponse.text()
        throw new Error(`Gemini API error: ${geminiResponse.status} - ${errorText}`)
      }

      const geminiData: GeminiResponse = await geminiResponse.json()
      const processingTime = Date.now() - startTime

      if (!geminiData.candidates || geminiData.candidates.length === 0) {
        throw new Error('No content generated by Gemini')
      }

      const generatedContent = geminiData.candidates[0].content.parts[0].text

      // Parse the generated content based on type
      const parsedContent = parseGeneratedContent(request.contentType, generatedContent)

      // Update the request record with success
      await supabaseClient
        .from('ai_content_requests')
        .update({
          status: 'completed',
          response_data: parsedContent,
          tokens_used: geminiData.usageMetadata?.totalTokenCount || 0,
          processing_time_ms: processingTime,
          completed_at: new Date().toISOString()
        })
        .eq('id', requestRecord.id)

      // Create the actual content in the database
      const createdContent = await createContentInDatabase(
        supabaseClient,
        request.userId,
        request.contentType,
        parsedContent,
        request.parameters
      )

      return new Response(
        JSON.stringify({
          success: true,
          requestId: requestRecord.id,
          contentType: request.contentType,
          content: createdContent,
          tokensUsed: geminiData.usageMetadata?.totalTokenCount || 0,
          processingTimeMs: processingTime
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      )

    } catch (error) {
      const processingTime = Date.now() - startTime

      // Update request record with error
      await supabaseClient
        .from('ai_content_requests')
        .update({
          status: 'failed',
          error_message: error.message,
          processing_time_ms: processingTime,
          completed_at: new Date().toISOString()
        })
        .eq('id', requestRecord.id)

      throw error
    }

  } catch (error) {
    console.error('Error in generate-study-content:', error)
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    )
  }
})

function getSystemPrompt(contentType: string, parameters: any): string {
  const basePrompt = `You are an expert language learning content creator specializing in interpretation and translation training. Create high-quality, pedagogically sound content.`

  switch (contentType) {
    case 'learning_path':
      return `${basePrompt}

Create a comprehensive learning path with the following structure:
- Title and description
- List of lessons with titles, descriptions, and learning objectives
- Estimated duration for each lesson
- Progressive difficulty
- Practical exercises and assessments

Return the response as valid JSON with this structure:
{
  "title": "Learning Path Title",
  "description": "Detailed description",
  "category": "${parameters.category || 'general'}",
  "difficulty_level": "${parameters.difficulty || 'intermediate'}",
  "language_pair": "${parameters.languagePair || 'en-es'}",
  "estimated_duration_minutes": 0,
  "lessons": [
    {
      "title": "Lesson Title",
      "description": "Lesson description",
      "lesson_type": "vocabulary|grammar|listening|reading|practice|assessment",
      "order_index": 1,
      "estimated_duration_minutes": 30,
      "learning_objectives": ["objective1", "objective2"],
      "key_terms": {"term1": "definition1", "term2": "definition2"}
    }
  ]
}`

    case 'lesson':
      return `${basePrompt}

Create a detailed lesson with comprehensive content including:
- Clear learning objectives
- Key vocabulary terms with definitions
- Practical exercises
- Examples and explanations
- Assessment questions

Return as valid JSON with this structure:
{
  "title": "Lesson Title",
  "content": "Detailed lesson content in markdown format",
  "lesson_type": "vocabulary|grammar|listening|reading|practice|assessment",
  "difficulty_level": "${parameters.difficulty || 'intermediate'}",
  "estimated_duration_minutes": 30,
  "learning_objectives": ["objective1", "objective2"],
  "key_terms": {"term1": "definition1"},
  "practice_exercises": [
    {
      "type": "multiple_choice|fill_blank|translation",
      "question": "Question text",
      "options": ["option1", "option2", "option3", "option4"],
      "correct_answer": 0,
      "explanation": "Why this is correct"
    }
  ]
}`

    case 'flashcards':
      return `${basePrompt}

Create flashcards for spaced repetition learning. Each flashcard should have:
- Front text (source language)
- Back text (target language)
- Example sentence
- Pronunciation guide if applicable

Return as valid JSON array:
[
  {
    "front_text": "Source language term",
    "back_text": "Target language translation",
    "front_language": "${parameters.sourceLanguage || 'en'}",
    "back_language": "${parameters.targetLanguage || 'es'}",
    "category": "${parameters.category || 'general'}",
    "difficulty_level": "${parameters.difficulty || 'intermediate'}",
    "example_sentence": "Example using the term",
    "pronunciation_guide": "Phonetic pronunciation"
  }
]`

    case 'quiz':
      return `${basePrompt}

Create a comprehensive quiz with various question types:
- Multiple choice
- Fill in the blank
- True/false
- Matching

Return as valid JSON:
{
  "title": "Quiz Title",
  "description": "Quiz description",
  "quiz_type": "mixed",
  "time_limit_minutes": 30,
  "passing_score": 70,
  "questions": [
    {
      "type": "multiple_choice|fill_blank|true_false|matching",
      "question": "Question text",
      "options": ["option1", "option2", "option3", "option4"],
      "correct_answer": 0,
      "explanation": "Explanation of correct answer",
      "points": 1
    }
  ]
}`

    default:
      return `${basePrompt}

Create educational content based on the user's request. Ensure it's accurate, pedagogically sound, and appropriate for the specified difficulty level.`
  }
}

function parseGeneratedContent(contentType: string, content: string): any {
  try {
    // Try to extract JSON from the content
    const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || content.match(/\{[\s\S]*\}/) || content.match(/\[[\s\S]*\]/)

    if (jsonMatch) {
      return JSON.parse(jsonMatch[1] || jsonMatch[0])
    }

    // If no JSON found, return the raw content
    return { content: content }
  } catch (error) {
    console.error('Error parsing generated content:', error)
    return { content: content, parseError: error.message }
  }
}

async function createContentInDatabase(
  supabaseClient: any,
  userId: string,
  contentType: string,
  parsedContent: any,
  parameters: any
): Promise<any> {
  switch (contentType) {
    case 'learning_path':
      return await createLearningPath(supabaseClient, userId, parsedContent)

    case 'lesson':
      return await createLesson(supabaseClient, userId, parsedContent, parameters)

    case 'flashcards':
      return await createFlashcards(supabaseClient, userId, parsedContent)

    case 'quiz':
      return await createQuiz(supabaseClient, userId, parsedContent, parameters)

    default:
      return parsedContent
  }
}

async function createLearningPath(supabaseClient: any, userId: string, content: any) {
  // Create the learning path
  const { data: learningPath, error: pathError } = await supabaseClient
    .from('learning_paths')
    .insert({
      user_id: userId,
      title: content.title,
      description: content.description,
      category: content.category,
      difficulty_level: content.difficulty_level,
      language_pair: content.language_pair,
      total_lessons: content.lessons?.length || 0,
      estimated_duration_minutes: content.estimated_duration_minutes,
      created_by_ai: true
    })
    .select()
    .single()

  if (pathError) throw pathError

  // Create the lessons
  if (content.lessons && Array.isArray(content.lessons)) {
    const lessons = content.lessons.map((lesson: any, index: number) => ({
      learning_path_id: learningPath.id,
      user_id: userId,
      title: lesson.title,
      content: lesson.description || '',
      lesson_type: lesson.lesson_type || 'vocabulary',
      order_index: lesson.order_index || index + 1,
      estimated_duration_minutes: lesson.estimated_duration_minutes || 30,
      learning_objectives: lesson.learning_objectives || [],
      key_terms: lesson.key_terms || {},
      ai_generated: true
    }))

    const { error: lessonsError } = await supabaseClient
      .from('lessons')
      .insert(lessons)

    if (lessonsError) throw lessonsError
  }

  return learningPath
}

async function createLesson(supabaseClient: any, userId: string, content: any, parameters: any) {
  const { data: lesson, error } = await supabaseClient
    .from('lessons')
    .insert({
      learning_path_id: parameters.learningPathId,
      user_id: userId,
      title: content.title,
      content: content.content,
      lesson_type: content.lesson_type || 'vocabulary',
      order_index: parameters.orderIndex || 1,
      estimated_duration_minutes: content.estimated_duration_minutes || 30,
      learning_objectives: content.learning_objectives || [],
      key_terms: content.key_terms || {},
      practice_exercises: content.practice_exercises || [],
      ai_generated: true
    })
    .select()
    .single()

  if (error) throw error
  return lesson
}

async function createFlashcards(supabaseClient: any, userId: string, content: any) {
  if (!Array.isArray(content)) {
    throw new Error('Flashcards content must be an array')
  }

  const flashcards = content.map((card: any) => ({
    user_id: userId,
    front_text: card.front_text,
    back_text: card.back_text,
    front_language: card.front_language,
    back_language: card.back_language,
    category: card.category,
    difficulty_level: card.difficulty_level,
    example_sentence: card.example_sentence,
    pronunciation_guide: card.pronunciation_guide,
    ai_generated: true
  }))

  const { data, error } = await supabaseClient
    .from('flashcards')
    .insert(flashcards)
    .select()

  if (error) throw error
  return data
}

async function createQuiz(supabaseClient: any, userId: string, content: any, parameters: any) {
  const { data: quiz, error } = await supabaseClient
    .from('quizzes')
    .insert({
      user_id: userId,
      lesson_id: parameters.lessonId,
      learning_path_id: parameters.learningPathId,
      title: content.title,
      description: content.description,
      quiz_type: content.quiz_type || 'mixed',
      questions: content.questions || [],
      time_limit_minutes: content.time_limit_minutes,
      passing_score: content.passing_score || 70,
      ai_generated: true
    })
    .select()
    .single()

  if (error) throw error
  return quiz
}
